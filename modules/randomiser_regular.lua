regular_map_table = {
	[1] = 0x0400,
	[2] = 0x0600,
	[3] = 0x0701,
	[4] = 0x0702,
	[5] = 0x0705,
	[6] = 0x0708,
	[7] = 0x070E,
	[8] = 0x070F,
	[9] = 0x0C00,
	[10] = 0x0D00,
	[11] = 0x0E00,
	[12] = 0x7001,
	[13] = 0x1300,
	[14] = 0x2203,
	[15] = 0x1500,
	[16] = 0x1600,
	[17] = 0x1700,
	[18] = 0x1800,
	[19] = 0x1A00,
	[20] = 0x1A03,
	[21] = 0x1A10,
	[22] = 0x1B00,
	[23] = 0x1D00,
	[24] = 0x1E00,
	[25] = 0x1E01,
	[26] = 0x1E02,
	[27] = 0x1E03,
	[28] = 0x1E04,
	[29] = 0x1E05,
	[30] = 0x1E06,
	[31] = 0x1E07,
	[32] = 0x1E08,
	[33] = 0x1E09,
	[34] = 0x1E0A,
	[35] = 0x1E0B,
	[36] = 0x1E13,
	[37] = 0x1E14,
	[38] = 0x1E15,
	[39] = 0x1F00,
	[40] = 0x2100,
	[41] = 0x2202,
	[42] = 0x2204,
	[43] = 0x2205,
	[44] = 0x2206,
	[45] = 0x2207,
	[46] = 0x2208,
	[47] = 0x2209,
	[48] = 0x220A,
	[49] = 0x220B,
	[50] = 0x220D,
	[51] = 0x2400,
	[52] = 0x2500,
	[53] = 0x2600,
	[54] = 0x2601,
	[55] = 0x2602,
	[56] = 0x2603,
	[57] = 0x2604,
	[58] = 0x2605,
	[59] = 0x2606,
	[60] = 0x2607,
	[61] = 0x2611,
	[62] = 0x2613,
	[63] = 0x2700,
	[64] = 0x2900,
	[65] = 0x2B00,
	[66] = 0x2B01,
	[67] = 0x2B02,
	[68] = 0x2C00,
	[69] = 0x2D00,
	[70] = 0x2E00,
	[71] = 0x2E01,
	[72] = 0x2F00,
	[73] = 0x2F01,
	[74] = 0x3000,
	[75] = 0x3001,
	[76] = 0x3002,
	[77] = 0x3003,
	[78] = 0x3004,
	[79] = 0x3005,
	[80] = 0x3006,
	[81] = 0x3007,
	[82] = 0x3008,
	[83] = 0x3009,
	[84] = 0x300A,
	[85] = 0x300B,
	[86] = 0x300C,
	[87] = 0x300D,
	[88] = 0x300E,
	[89] = 0x300F,
	[90] = 0x3010,
	[91] = 0x3017,
	[92] = 0x3100,
	[93] = 0x3300,
	[94] = 0x3400,
	[95] = 0x3600,
	[96] = 0x3700,
	[97] = 0x3800,
	[98] = 0x3900,
	[99] = 0x3A00,
	[100] = 0x3B00,
	[101] = 0x3C00,
	[102] = 0x3D00,
	[103] = 0x3D01,
	[104] = 0x3E00,
	[105] = 0x3E01,
	[106] = 0x3E02,
	[107] = 0x3E03,
	[108] = 0x3F00,
	[109] = 0x4000,
	[110] = 0x4001,
	[111] = 0x4002,
	[112] = 0x4003,
	[113] = 0x4004,
	[114] = 0x4600,
	[115] = 0x4700,
	[116] = 0x4800,
	[117] = 0x4801,
	[118] = 0x4802,
	[119] = 0x4803,
	[120] = 0x4804,
	[121] = 0x4805,
	[122] = 0x4806,
	[123] = 0x480E,
	[124] = 0x480F,
	[125] = 0x4810,
	[126] = 0x4811,
	[127] = 0x4812,
	[128] = 0x4813,
	[129] = 0x4814,
	[130] = 0x481E,
	[131] = 0x5200,
	[132] = 0x5400,
	[133] = 0x5500,
	[134] = 0x5600,
	[135] = 0x5700,
	[136] = 0x5701,
	[137] = 0x5702,
	[138] = 0x5704,
	[139] = 0x5705,
	[140] = 0x5707,
	[141] = 0x5708,
	[142] = 0x5709,
	[143] = 0x570C,
	[144] = 0x570D,
	[145] = 0x570E,
	[146] = 0x5710,
	[147] = 0x5714,
	[148] = 0x5800,
	[149] = 0x5801,
	[150] = 0x5900,
	[151] = 0x5A00,
	[152] = 0x5B00,
	[153] = 0x5C00,
	[154] = 0x5D00,
	[155] = 0x5E00,
	[156] = 0x5F00,
	[157] = 0x6200,
	[158] = 0x6400,
	[159] = 0x6900,
	[160] = 0x6A00,
	[161] = 0x6C00,
	[162] = 0x6E00,
	[163] = 0x7000,
	[164] = 0x7100,
	[165] = 0x7101,
	[166] = 0x7102,
	[167] = 0x7200,
	[168] = 0x7201,
	[169] = 0x9700,
	[170] = 0x9702,
	[171] = 0x9704,
	[172] = 0xA300,
	[173] = 0xA400,
	[174] = 0xA600,
	[175] = 0xA700,
	[176] = 0xA800,
	[177] = 0xA900,
	[178] = 0xA901,
	[179] = 0xAD00,
	[180] = 0xAD01,
	[181] = 0xAE00,
	[182] = 0xAE01,
	[183] = 0xAF00,
	[184] = 0xAF01,
	[185] = 0xB200,
	[186] = 0xB201,
	[187] = 0xB300,
	[188] = 0xB700,
	[189] = 0xB703,
	[190] = 0xB704,
	[191] = 0xB900,
	[192] = 0xBA00,
	[193] = 0xBB00,
	[194] = 0xBC00,
	[195] = 0xBD00,
	[196] = 0xC100,
	[197] = 0xC101,
	[198] = 0xC200,
	[199] = 0xC201,
	[200] = 0xC300,
	[201] = 0xC800,
	[202] = 0x570F,
	[203] = 0x570B,
	[204] = 0x1A08,
};

boss_map_table = {
	[1] = 8,
	[2] = 83,
	[3] = 111,
	[4] = 154,
	[5] = 196,
	[6] = 197,
	[7] = 199
};

tns_parent_maps_table = {
	[1] = {0x7}, -- Japes (Japes Main Map)
	[2] = {0x26}, -- Aztec (Aztec Main, 
	[3] = {0x1A}, -- Factory
	[4] = {0x1E}, -- Galleon
	[5] = {0x30}, -- Fungi
	[6] = {0x48}, -- Caves
	[7] = {0x57, 0x97, 0xB7}, -- Castle
};

k_rool_maps_table = {
	[1] = {0xCB,5};
	[2] = {0xCC,4};
	[3] = {0xCD,7};
	[4] = {0xCE,4};
	[5] = {0xCF,5};
};

keys = {
	-- [key] = {obtained, {keyFlagByte, keyFlagBit}, {tnsFlagByte, tnsFlagBit}}
	[1] = {0, {0x3,2}, {0x5,6}},
	[2] = {0, {0x9,2}, {0xD,4}},
	[3] = {0, {0x11,2}, {0x13,0}},
	[4] = {0, {0x15,0}, {0x19,3}},
	[5] = {0, {0x1D,4}, {0x20,2}},
	[6] = {0, {0x24,5}, {0x25,6}},
	[7] = {0, {0x27,5}, {0x2C,0}},
	[8] = {0, {0x2F,4}, {0xFFFF,0}}, -- Dummy Flag used for T&S clear
};

boss_door_kong_permits = {
	[1] = {1, 2, 3, 4, 5}, -- Army Dillo 1
	[2] = {1, 2, 3, 4, 5}, -- Dogadon 1
	[3] = {1, 2, 4, 5}, -- Mad Jack
	[4] = {1, 2, 3, 4, 5}, -- Pufftoss
	[5] = {5}, -- Dogadon 2
	[6] = {1, 2, 3, 5}, -- Army Dillo 2
	[7] = {1, 2, 3, 4, 5}, -- King Kut Out
};

boss_door_range = { -- Normal amount is 1680
	[1] = 1000, -- Min
	[2] = 2000, -- Max
};

key_take_occurred = 0;
key_give_occurred = 0;

function keySwap()
	transition_speed_value = mainmemory.readfloat(Mem.transition_speed[version], true);
	zipProg = mainmemory.readbyte(Mem.zipper_progress[version]);
	current_dmap = mainmemory.read_u32_be(Mem.dmap[version]);
	if transition_speed_value < 0 then
		if zipProg < 3 and key_take_occurred == 0 then
			for i = 1, 8 do
				if checkFlag(keys[i][2][1],keys[i][2][2]) then
					keys[i][1] = 1;
					clearFlag(keys[i][2][1], keys[i][2][2]);
					--print("Set array for key "..i.." to 1");
				else
					--keys[i][1] = 0;
					--print("Set array for key "..i.." to 0");
				end
			end
			key_take_occurred = 1;
			--print("Taken Keys");
		elseif zipProg > 30 and zipProg < 40 and key_give_occurred == 0 and current_dmap ~= 42 then
			for i = 1, 8 do
				if keys[i][1] == 1 then
					setFlag(keys[i][2][1], keys[i][2][2]);
				end
			end
			key_give_occurred = 1;
			--print("Returned Keys");
		end
	end
	if transition_speed_value > 0 and zipProg < 3 then
		key_take_occurred = 0;
		key_give_occurred = 0;
		for i = 1, 7 do
			clearFlag(keys[i][3][1], keys[i][3][2]);
		end
		--print("Reset key swap bits");
	end
end

function reprintRMTable()
	RMTcounter = 0;
	for i = 1, 262 do
		if regular_map_table[i] ~= nil then
			RMTcounter = RMTcounter + 1;
			print("["..RMTcounter.."] = "..toHexString(regular_map_table[i],4)..",");
		end
	end
end

function generateAssortment()
	temporary_regular_map_assortment = {};
	regular_map_assortment = {};
	regular_seedSetting = seedAsNumber * 1000;
	for i = 1, #regular_map_table do
		temporary_regular_map_assortment[i] = i;
	end
	math.randomseed(regular_seedSetting);
	for i = 1, #regular_map_table do
		selected_temp_value = math.ceil(math.random() * #temporary_regular_map_assortment);
		if selected_temp_value == 0 then
			selected_temp_value = 1;
		end
		regular_map_assortment[i] = temporary_regular_map_assortment[selected_temp_value];
		table.remove(temporary_regular_map_assortment, selected_temp_value);
		--print("RMS: Entry "..i..", selected random value "..selected_temp_value);
	end
end

function generateBossAssortment()
	temporary_boss_map_assortment = {};
	boss_map_assortment = {};
	boss_seedSetting = seedAsNumber * 10;
	for i = 1, #boss_map_table do
		temporary_boss_map_assortment[i] = i;
	end
	math.randomseed(boss_seedSetting);
	for i = 1, #boss_map_table do
		selected_temp_value = math.ceil(math.random() * #temporary_boss_map_assortment);
		if selected_temp_value == 0 then
			selected_temp_value = 1;
		end
		boss_map_assortment[i] = temporary_boss_map_assortment[selected_temp_value];
		table.remove(temporary_boss_map_assortment, selected_temp_value);
	end
end

function generateBossDoorAssortment()
	boss_door_assortment = {};
	boss_door_seedSetting = seedAsNumber + 5;
	math.randomseed(boss_seedSetting);
	for i = 1, #boss_door_kong_permits do
		selected_temp_value = math.ceil(math.random() * #boss_door_kong_permits[i]);
		if selected_temp_value == 0 then
			selected_temp_value = 1;
		end
		boss_door_assortment[i] = boss_door_kong_permits[i][selected_temp_value];
	end
end

function validateData(value)
	for i = 1, #regular_map_assortment do
		if regular_map_assortment[i] == value then
			print(i)
		end
	end
end

function testRegularMapAssortment()
	temp_table = {};
	for i = 1, #regular_map_table do
		temp_table[i] = i;
	end
	temp_removal_table = {};
	temp_removal_counter = 0;
	for i = 1, #regular_map_table do
		for j = 1, #regular_map_table do
			if regular_map_assortment[i] == j then
				temp_removal_counter = temp_removal_counter + 1;
				temp_removal_table[temp_removal_counter] = j;
			end
		end
	end
	for i = temp_removal_counter, 1, -1 do
		table.remove(temp_table, i);
	end
	if #temp_table > 0 then
		for i = 1, #temp_table do
			print("Table Entry "..temp_table[i].." missing from regular map assortment");
		end
	end
end

function generateTnSNumberAssortment()
	tns_number_assortment = {};
	for i = 1, 7 do
		tns_number_assortment[i] = 0;
	end
	tns_priority = {};
	tns_temp_priority = {};
	for i = 1, 7 do
		tns_temp_priority[i] = i;
	end
	tns_number_seedSetting = seedAsNumber + 120;
	math.randomseed(tns_number_seedSetting);
	for i = 1, 7 do
		selected_value = math.ceil(math.random() * #tns_temp_priority);
		if selected_value == 0 then
			selected_value = 1;
		end
		selected_value2 = tns_temp_priority[selected_value];
		tns_priority[i] = selected_value2;
	end
	tns_probability_array = {};
	tns_array_counter = 0;
	for i = 1, 7 do
		for j = 1, tns_priority[i] do
			tns_array_counter = tns_array_counter + 1;
			tns_probability_array[tns_array_counter] = i;
		end
	end
	difference = (boss_door_range[2] - boss_door_range[1]) + 1;
	tns_total_temp = (boss_door_range[1] - 1) + math.ceil(math.random() * difference);
	if tns_total_temp < boss_door_range[1] then
		tns_total_temp = boss_door_range[1];
	end
	tns_total = tns_total_temp - (tns_total_temp % 5);
	tns_running_total = tns_total;
	for i = 1, (tns_total / 5) do
		selected_level_value = math.ceil(math.random() * #tns_probability_array);
		if selected_level_value == 0 then
			selected_level_value = 1;
		end
		selected_level = tns_probability_array[selected_level_value];
		tns_number_assortment[selected_level] = tns_number_assortment[selected_level] + 5;
		tns_running_total = tns_running_total - 5;
		list_to_remove = {};
		removal_count_tns = 0;
		if tns_number_assortment[1] == 200 then -- Japes at 200
			for j = 1, #tns_probability_array do
				if tns_probability_array[j] == 1 then
					removal_count_tns = removal_count_tns + 1;
					list_to_remove[removal_count_tns] = j;
				end
			end
		end
		if tns_number_assortment[2] == 400 then -- Aztec at 400
			for j = 1, #tns_probability_array do
				if tns_probability_array[j] == 2 then
					removal_count_tns = removal_count_tns + 1;
					list_to_remove[removal_count_tns] = j;
				end
			end
		end
		for k = 3, 7 do
			if tns_number_assortment[k] == 500 then -- Aztec at 400
				for j = 1, #tns_probability_array do
					if tns_probability_array[j] == k then
						removal_count_tns = removal_count_tns + 1;
						list_to_remove[removal_count_tns] = j;
					end
				end
			end
		end
		if #list_to_remove > 0 then
			for j = #list_to_remove, 1, -1 do
				table.remove(tns_probability_array, j);
			end
		end
	end
end

function generateKRoolOrder()
	temporary_k_rool_table = {};
	k_rool_assortment = {};
	k_rool_seedSetting = seedAsNumber * 10000;
	for i = 1, 4 do
		temporary_k_rool_table[i] = i;
	end
	math.randomseed(k_rool_seedSetting);
	for i = 1, 4 do
		selected_temp_value = math.ceil(math.random() * #temporary_k_rool_table);
		if selected_temp_value == 0 then
			selected_temp_value = 1;
		end
		k_rool_assortment[i] = temporary_k_rool_table[selected_temp_value];
		table.remove(temporary_k_rool_table, selected_temp_value);
	end
	k_rool_assortment[5] = 5; -- Always ends on Chunky Phase
end

function setAssortments()
	generateAssortment();
	generateBossAssortment();
	generateKRoolOrder();
	generateBossDoorAssortment();
	generateTnSNumberAssortment();
end

function getExitName(map_index, exit_index)
	for i = 1, #mapsWithMultipleExits  do
        if map_index == mapsWithMultipleExits[i] then
			local exitName = exitTable[map_index][exit_index + 1];
			assert(exitName ~= nil, "Invalid or unknown exit! Map: "..maps[map_index + 1]..", Exit: " ..exit_index);
			return exitName;
		end
    end
    return exit_index;
end

function getLoadingZone(destmap, destexit)
	reference = nil;
	lookup_value = (destmap * 256) + destexit;
	for i = 1, #regular_map_table do
		if regular_map_table[i] == lookup_value then
			reference = i;
		end
	end
	if reference == nil then
		print("Value maintained as "..lookup_value);
		return lookup_value;
	else
		value_to_lookup = regular_map_assortment[reference];
		new_dmap_code = regular_map_table[value_to_lookup];
		print("Value set to as "..new_dmap_code);
		return new_dmap_code;
	end
end

function getBossDestination(parent_map)
	reference = nil;
	for i = 1, #tns_parent_maps_table do
		for j = 1, #tns_parent_maps_table[i] do
			if tns_parent_maps_table[i][j] == parent_map then
				reference = i;
			end
		end
	end
	if reference == nil then
		return destmap;
	else
		value_to_lookup = boss_map_assortment[reference];
		new_dmap_code = boss_map_table[value_to_lookup];
		return new_dmap_code;
	end
end

function getKRoolDestination(destmap)
	reference = nil;
	for i = 1, #k_rool_maps_table do
		if k_rool_maps_table[i][1] == destmap then
			reference = i;
		end
	end
	if reference == nil then
		return destmap;
	else
		new_dmap_code = k_rool_maps_table[k_rool_assortment[reference]][1];
		return new_dmap_code;
	end
end

function setTnSDoorStuff()
	for i = 0, 6 do
		mainmemory.write_u16_be(Mem.tnsdoor_header[version] + (2 * i), tns_number_assortment[i + 1]);
	end
	for i = 1, 7 do
		mainmemory.writebyte(Mem.tnsdoor_header[version] + 0x30 + (boss_map_assortment[i] - 1), boss_door_assortment[boss_map_assortment[i]] - 1);
	end
end

level_index_flags = {
	[0] = {0x38,5}, -- Japes
	[1] = {0x38,6}, -- Aztec
	[2] = {0x38,7}, -- Factory
	[3] = {0x39,0}, -- Galleon
	[4] = {0x39,1}, -- Fungi
	[5] = {0x39,2}, -- Caves
	[6] = {0x39,3}, -- Castle
	[7] = {0xFFFF,0}, -- Isles
	[8] = {0x39,4}, -- Helm
};

function checkMap(map_value)
	levelIndex = mainmemory.readbyte(Mem.level_index_mapping[version] + map_value);
	dmapType = mapType(current_dmap);
	if level_index_flags[levelIndex][1] ~= 0xFFFF then -- Not Isles
		if not checkFlag(level_index_flags[levelIndex][1], level_index_flags[levelIndex][2]) then
			setFlag(level_index_flags[levelIndex][1], level_index_flags[levelIndex][2]);
		end
	end
end

--event.onframestart(keySwap, "Swaps keys out to prevent T&S portal disappearing");